# 实验二
在这个实验中，要写关于操作系统的内存管理的代码，主要包括两个部分：   
1、内核的物理内存分配将内存分段    
2、虚拟内存机制   

新加入的文件有：
* inc/memlayout.h
* kern/pmap.c
* kern/pmap.h
* kern/kclock.h
* kern/kclock.c
memlayout.h描述了虚拟内存空间的布局，你需要修改pmap.c，memlayout.h和pmap.h定义了PageInfo结构体追踪那些page的物理内存是空闲的。kclock.c和kclock.h操作pc的电池时钟和CMOS RAM设备，在RAM设备中BIOS记录了PC物理内存的数量。在pmap.c的代码中，为了知道物理内存大小的数量需要阅读设备硬件代码，但是这些代码需要你来完成，你不需要知道CMOS硬件如何工作。
## 第一部分：物理内存管理
操作系统需要一直跟踪并了解那块区域的物理RAM是空闲的、那一块区域是正在被使用的，JOS管理物理内存是以页为单位的通过的MMU映射和保护每个分配的内存；  
#### 练习1
    在文件kern/pmap.c，实现下列函数：
    boot_alloc();
    mem_init()
    page_init()
    page_alloc()
    page_free()
    check_page_free_list()与check_page_alloc() 测试你的物理页分配器，你应该启动JOS看是否check_page_alloc报告成功，assert指令会比较有用;

* boot_alloc()与mem_init()  
这个函数只有mem_init()函数中被调用，第一次被调用是创建一级页表，也就是page_dir，一共有4096个字节，也就是最多有1024个二级页表，同样的一个page_table最多有1024个对应的页，每一个页是4kb，所以二级页表最多映射4GB的内存；然后将page_dir的PADDR(uvpt)，也就是page_dir自己占有的页设置权限，然后就是mem_init需要补充的部分，其实注释中写的比较清楚，让你分配一共npages大小的结构体数组，npages这个变量在i386_detect_memory函数中被初始化。代码与注释如下，注意此时不能用malloc，因为还没有建立虚拟内存机制。
```
//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo *)boot_alloc(npages * sizeof (struct PageInfo));
	memset(pages, 0, npages * sizeof (struct PageInfo) );
```
```
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
	nextfree = ROUNDUP(nextfree + n , PGSIZE);
	if ((int)(nextfree - KERNBASE) > npages * PGSIZE)
		panic("Out of memory\n");
	return result;
}
```

* page_init()   
这个函数用于追踪当前的物理内存使用情况，使用过的内存，记录其引用的个数，对于空闲的内存，将其用链表进行管理，这个函数的注释上写的比较明白，第一个page说保存中断描述表和BIOS的，这个在lab3中被使用； [PGSIZE , npages_basemem * PGSIZE]属于空闲区域，将其链接至链表； 
```
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	
	size_t i;
	//第一页标记为使用,IDT表等已经使用
	pages[0].pp_ref = 1;

	//[PGSIZE, npages_basemem * PGSIZE) is free
	for (i = 1; i < npages_basemem; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	
	///[IOPHYSMEM, EXTPHYSMEM) 被占用， lab1的IO空间到bios空间
	for (i = IOPHYSMEM / PGSIZE ; i < EXTPHYSMEM / PGSIZE ; i ++)
		pages[i].pp_ref = 1;

	// boot_alloc 找到目前第一个空闲内存块地址，从EXTPHYSMEM到这个地址，都是被占用的
	physaddr_t kern_free_addr = PADDR(boot_alloc(0));
	for ( ; i < kern_free_addr / PGSIZE ; i ++)
		pages[i].pp_ref = 1;
	// 后续地址均未使用
	for (; i < npages; i ++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}	
}

```

* page_alloc()
这个函数就比较容易了，就从链表中取出一个page，并初始化这个page的内容；
```
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	// 是否还有多余的空闲页，若没有直接返回NULL
	if (page_free_list == NULL)
		return NULL;
	// 从链表中取出一个page
	struct PageInfo *pRet;
	pRet = page_free_list;
	page_free_list = pRet->pp_link;
	pRet->pp_link = NULL;

	if (alloc_flags & ALLOC_ZERO){
		void *va = page2kva(pRet);
		memset(va, '\0', PGSIZE);
	}
		 
	return pRet;
}
```
* page_free   
直接将这个page的结构体，加入链表中，首先需要确定该page的页引用是否为0。


```
//
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0 || pp->pp_link != NULL){
		panic("this page's ref not zero or page's pLink is not NULL\n");
		return;
	}
	//pp->pp_ref = 0;
	pp->pp_link = page_free_list;
	page_free_list = pp;

}
```


        

## 第二部分: 虚拟内存
在x86架构中，虚拟内存机制包括段选择器与段内偏移，线性地址是从段转换得到的地址，物理地址是通过页转换得到，在通过硬件总线从RAM进行寻址；  
```
      	   Selector  +--------------+         +-----------+
          ---------->|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |-------->|           |---------->  RAM
            Offset   |  Mechanism   |         | Mechanism |
          ---------->|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical

```
一个C指针是虚拟地址的偏移量，在boot/boot.S中，我们加载了全局描述表，这个表将所有段的基址设置为0，因此段选择器不起作用了，所以虚拟地址恒等于这个偏移量，在lab3中我们会引入分段机制，但是目前可以忽略这个机制。  
在lab1的第三部分，已经实现一个简单的页表，将地址0xf0100000映射到0x00100000，但是只映射了前4MB的内存，现在我们将他扩展到256MB空间，将其映射到以0xf0000000开始的空间，或者其他空间。  
#### 练习3
        通过GDB，我们只能通过虚拟地址来查看内存所存放的内容，但是如果我们能够访问物理内存的话，肯定会更有帮助的。我们可以看一下QEMU中的一些常用指令，特别是xp指令，可以允许我们去访问物理内存地址。
一旦运行保护模式后，所有的内存地址都被解释为虚拟内存地址,没有其他的方法使用线性地址或者是物理地址，所有的地址都被解释为虚拟地址，被MMU进行翻译；如何进行“翻译”如下图
![图片](./虚拟地址格式.png)
为了区分不一样的地址，在代码中用不同的宏定义加以区分
|C type| Address Type|
|------|-------------|
| T*   |虚拟地址 |
|uintpt_t | 虚拟地址|
|physaddr_t | 物理地址 |

#### 问题
下列代码中x是什么类型的地址？
```
    mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;
```
回答：虚拟地址,也就是uintptr_ t,因为他直接由操作系统进行寻址，是通过MMU进行寻址。  

JOS内核有时需要读取或者修改内存，但是这时有可能他只知道这个要被修改的内存的物理地址。举个例子，当我们想要加入一个新的页表项时，我们需要分配一块物理内存来存放页目录项，然后初始化这块内存。然而，内核，它是不能绕过 虚拟地址转换 这一步的，因而它也不能直接加载或者存储物理地址。那么我们如何把物理地址转换为虚拟地址，我们可以采用KADDR(pa)指令来获取。其中pa指的是物理地址。

同样的，如果想通过虚拟地址的值求得物理地址的值，我们可以采用PADDR(va)指令。

### 引用计数
在之后的实验中，你将会经常遇到一种情况，多个不同的虚拟地址被同时映射到相同的物理页上面。这时我们需要记录一下每一个物理页上存在着多少不同的虚拟地址来引用它，这个值存放在这个物理页的PageInfo结构体的pp_ref成员变量中。当这个值变为0时，这个物理页才可以被释放。通常来说，任意一个物理页p的pp_ref值等于它在所有的页表项中，被位于虚拟地址UTOP之下的虚拟页所映射的次数（UTOP之上的地址范围在启动的时候已经被映射完成了，之后不会被改动）。

   当我们使用page_alloc函数的时候需要注意。它所返回的页的引用计数值总是0，所以pp_ref应该被马上加一

### 页表管理

#### 练习4
完成kern/pmap.c中的下面几个子函数的编码
        pgdir_walk()  
        boot_map_region()
        page_lookup()
        page_remove()
        page_insert()
　　    check_page()子函数将会被用来检查你所编写的这些程序是否正确。

* pgdir_walk(), 从虚拟地址中找对应页目录指向页表是否存在，按要求创建这个页表，实际上页表的上保存的内容包括该页表或者该页的物理地址，还包括读写权限等，格式[如该网页所示](https://pdos.csail.mit.edu/6.828/2018/lec/x86_translation_and_registers.pdf)

```
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	pte_t *pgTablePage = pgdir + PDX(va);
	// 二级页表是否存在
	if ( !(*pgTablePage & PTE_P)){
		// not creat  return false
		if (create == false)
			return NULL;
		else{
			// 分配新的页表
			struct PageInfo *newPage = page_alloc(1);
			// 是否分配成，分配成功则，引用计数 + 1
			if (newPage == NULL)
				return NULL;
			newPage->pp_ref ++;
			//将二级页表权限与物理地址写入
			*pgTablePage = (page2pa(newPage) | PTE_P | PTE_W | PTE_U);
			
		}
	}
	uint32_t pageOffset = PTX(va);
	//  物理地址转为虚拟地址
	pte_t *page_base = (pte_t *)KADDR(PTE_ADDR(*pgTablePage));
	return page_base + pageOffset;
}
```

* boot_map_region(),虚拟地址与实际物理地址进行对应，其实就是按虚拟地址找对应的页目录page_dir，在目录中填物理地址,并按照要求给予对应权限perm。   

```
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	
	for (size_t i = 0; i < size; i += PGSIZE){
		pte_t *pgTable = pgdir_walk(pgdir, (void *)(va + i), true);
		*pgTable = ((pa + i) | perm | PTE_P);
	}
}
```
* page_lookup(),用于找虚拟地址对应的页表是否存在。
```
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	
	pte_t *pageTable = pgdir_walk(pgdir, va, 0);
	if (pageTable == NULL)
		return NULL;
	// 页表是否存在
	if (! (*pageTable & PTE_P))
		return NULL;
	// 页表地址是否通过形参地址返回
	if (pte_store)
		*pte_store = pageTable;
	return pa2page(PTE_ADDR(*pageTable));
}
```

* page_remove()
```
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t *pageTable = NULL;
	struct PageInfo *pPage = page_lookup(pgdir, va, &pageTable);
	if (pPage == NULL)
		return;
	page_decref(pPage);
	*pageTable = 0;
	tlb_invalidate(pgdir, va); // 页表缓存清除
}
```

* page_insert()
```

int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
	pte_t *pageTable = pgdir_walk(pgdir, va, true);
	if (! pageTable)
		return -E_NO_MEM;
	pp->pp_ref ++;
	if ((*pageTable & PTE_P)){
		page_remove(pgdir, va);
	}
	*pageTable = (page2pa(pp) | perm | PTE_P);
	return 0;
}
```
## 内核地址空间
JOS把32位线性地址虚拟空间划分成两个部分。其中用户环境（进程运行环境）通常占据低地址的那部分，叫用户地址空间。而操作系统内核总是占据高地址的部分，叫内核地址空间。这两个部分的分界线是定义在memlayout.h文件中的一个宏 ULIM。JOS为内核保留了接近256MB的虚拟地址空间。这就可以理解了，为什么在实验1中要给操作系统设计一个高地址的地址空间。如果不这样做，用户环境的地址空间就不够了。

### 权限与隔离
由于内核和用户进程只能访问各自的地址空间，所以我们必须在x86页表中使用访问权限位(Permission Bits)来使用户进程的代码只能访问用户地址空间，而不是内核地址空间。否则用户代码中的一些错误可能会覆写内核中的数据，最终导致内核的崩溃。

处在用户地址空间中的代码不能访问高于ULIM的地址空间，但是内核可以读写这部分空间。而内核和用户对于地址范围[UTOP, ULIM]有着相同的访问权限，那就是可以读取但是不可以写入。这一个部分的地址空间通常被用于把一些只读的内核数据结构暴露给用户地址空间的代码。在UTOP之下的地址范围是给用户进程使用的，用户进程可以访问，修改这部分地址空间的内容。

### 初始化内核地址空间
现在我们要设置一下UTOP（也就是user top）之上的地址空间：这也是整个虚拟地址空间中的内核地址空间部分。inc/memlayout.h文件中已经向你展示了这部分地址空间的布局。你可以使用你刚刚编写的函数来设置这些地址的布局。

#### 练习5
        完善mem_init()函数通过check_kern_pgdir()和check_page_installed_pgdir()函数的检测。

#### 问题
1. 到目前位置页表目录表，有多少个有效的目录项，他们被映射到哪里，完成下列表格；

|Entry | Base Virtual Address | Point to (logically) |
|------|----------------------|----------------------|
|1023|?|PageTable for top 4MB of physical mem|
|1022|?|?|
|.|.|.|
|.|.|.|
|.|.|.|
|2|0x00800000|?|
|1|0x00400000|?|
|0|0x00000000|[see next question]|

2. 我们已经将用户空间与内核空间映射到同一的地址空间，为什么用户程序不允许修改内核的内存？什么样的机制保护了内核内存？
3. 操作系统的最大映射物理内存有多大，为什么？
4. 如何我们需要用到全部的物理地址，需要额外多大的空间对其进行管理？具体是如何计算的出管理空间大小的？
5. 在系统开始采用虚拟内存机制时，为什么EIP的地址没有出错？

回答：
1. 

2. 用户程序若可以修改内核内存，那么糟糕的程序会直接让操作系统崩溃，所以，需要进行用户态与内核态的隔离；隔离的机制是pageTable Entry中的权限位PTE_U/S进行区分； 如下图所示
![图片](./页表数据格式.png)

3. 看别人都说是UPAGE开始的4Mb，存pageInfo,自己没太捋清楚；

4. 4MB的pageInfo 对应1024个page，对应的页表是4kb * 1024 = 4mb，所以总共是8MB + 4kb；

5. 这个在lab1中已经回答过了，[0 4MB] 和 [0xf0000000 0xf010000000]都被映射到[0 4MB]的空间中，所以EIP的地址不用变化也可以正确找到下一条指令；





## 实验总结
这个实验主要实现与建立了基于分页的**内核**虚拟内存机制，主要功能包括虚拟内存的建立，包括初始化与多级页表机制（JOS展示的是两级页表），虚拟内存的多级页表的分配与回收机制，最后引出虚拟内存的用处：对内核信息进行保护的，其实还有用户态与用户态的隔离、简化编译的作用（这里没有进行过多的介绍）。

### 虚拟内存机制的建立
+ [虚拟内存的建立](#虚拟内存的建立)
	+ 内存页的初始化与管理
	+ 多级页表机制
+ [页表的分配与回收机制](#多级页表管理机制)
	+ 分配机制
	+ 回收机制
	+ 隔离机制


#### 虚拟内存的建立
操作系统的虚拟内存机制最主要的过程是虚拟地址与物理地址的映射关系如何建立，以及该映射关系如何进行动态维护。本小节应该说是回答了VA与PA的映射关系如何建立的过程。

VA与PA映射是一个查表的过程，虚拟内存中实际存储的是三个不同等级表格的偏移量，分别用PDX(Page Directory inDex),PTX(Page Table inDex),PGOFF(Page Offset)（也就是pgdir,pgtable,page的偏移量)，MMU对其的解析可以看成是三次间接寻址的过程，`*(*(*(pgdir + PDX) + PTX) + PGOFF)`，以上就是多级页表机制。

操作系统对首先探测有系统一共需要管理多少内存，同时根据内存大小，以4kb为粒度，创建一个内存页管理结构体数组，每个数组元素描述了一个内存页的信息，主要是该页的引用次数（用于了解该页的使用情况），与一个页管理指针（用于将空闲页使用链表管理）。由此建立了页管理数组，这个数组实现了对物理页的直接管理。

虚拟地址的建立流程是先通过建立内存页管理数组，根据目前操作系统应用情况，首先更新页管理数组中的空闲与占用情况，建立PageDir，最后将PageDir的地址填入控制寄存器CR3中，由此初步建立虚拟内存机制。


#### 多级页表管理机制
+ 分配机制  
在JOS中，空闲的page都会通过page_free_list链表进行管理，在程序启动的时候，操作系统会显式分配内存，并修改对应的多级页表。

+ 回收机制
JOS通过引用计数的方式来追踪该页是否被多个程序占用，当该page的计数为0的时候进行回收。

+ 多级页表实现隔离
	 + 内核态与用户态的隔离  
	 是通过pageTable Entry中的权限位来进行区分，如果用户态访问内核态的page会产生错误。
	 + 用户态与用户态的隔离  
	 是通过va与pa之间的映射关系不同来达到隔离的目的。